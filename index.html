<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>写真キャプション合成ツール（PC版・1ファイル）</title>

<!-- Google Fonts（必要最低限） -->
<link href="https://fonts.googleapis.com/css2?family=Zen+Antique&display=swap" rel="stylesheet">

<style>
/* ============================
   PC専用ダークテーマ CSS
============================ */

body {
  margin: 0;
  padding: 16px;
  background: #111;
  color: #eee;
  font-family: "Zen Antique", "Noto Sans JP", sans-serif;
}

h1 {
  margin: 0 0 12px;
  font-size: 20px;
}

.container {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 16px;
}

.panel {
  background: #181818;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 12px;
}

.panel h2 {
  margin: 0 0 8px;
  font-size: 14px;
  border-bottom: 1px solid #333;
  padding-bottom: 4px;
}

#dropZone {
  border: 2px dashed #666;
  border-radius: 8px;
  padding: 16px;
  text-align: center;
  color: #ccc;
  margin-bottom: 8px;
  cursor: pointer;
}

#dropZone.dragover {
  border-color: #4fc3f7;
  background: rgba(79,195,247,0.05);
}

button {
  padding: 6px 10px;
  border: 1px solid #555;
  background: #333;
  color: #eee;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #444;
}

.btn-row {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin: 10px 0;
}

.setting-block {
  margin: 10px 0;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.input-row {
  display: flex;
  gap: 6px;
  align-items: center;
}

.input-row input[type="range"] {
  flex: 1;
}

.input-row input[type="number"] {
  width: 80px;
}

.info {
  font-size: 11px;
  color: #aaa;
  max-height: 160px;
  overflow-y: auto;
}

.thumb-list {
  max-height: 200px;
  overflow-y: auto;
  font-size: 11px;
}

.thumb-item {
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
}

.thumb-item.active {
  background: #2e7d32;
}

.thumb-item:hover {
  background: #333;
}

.preview-wrapper {
  border: 1px solid #333;
  border-radius: 8px;
  height: calc(100vh - 80px);
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  background: #000;
}

.status {
  font-size: 11px;
  color: #aaa;
  margin-top: 4px;
}
</style>
</head>

<body>

<h1>写真キャプション合成ツール（PC版）</h1>

<div class="container">

  <!-- 左ペイン -->
  <div class="panel">
    <h2>画像読み込み</h2>

    <div id="dropZone">ここに画像をドロップ<br>またはクリックして選択</div>
    <input id="fileInput" type="file" accept="image/jpeg,image/png" multiple>

    <!-- 書き出しボタン -->
    <div class="btn-row">
      <button id="prevBtn">前へ</button>
      <button id="nextBtn">次へ</button>
      <button id="renderCurrentBtn">現在を書き出し</button>
      <button id="renderAllBtn">全て書き出し</button>
    </div>

    <!-- プリセット -->
    <div class="setting-block">
      <label>プリセット</label>
      <select id="presetSelect">
        <option value="none" selected>選択してください</option>
        <option value="g9m2">LUMIX G9M2 用</option>
        <option value="v1">PowerShot V1 用</option>
      </select>
    </div>

    <!-- 余白比率 -->
    <div class="setting-block">
      <label>余白比率（上・左右）</label>
      <div class="input-row">
        <input id="marginRatioSlider" type="range" min="0" max="0.20" step="0.01" value="0.03">
        <input id="marginRatioInput" type="number" min="0" max="1" step="0.01" value="0.03">
      </div>
    </div>

    <!-- フォントサイズ -->
    <div class="setting-block">
      <label>フォントサイズ</label>
      <div class="input-row">
        <input id="fontSizeSlider" type="range" min="8" max="300" step="1" value="118">
        <input id="fontSizeInput" type="number" min="8" max="300" step="1" value="118">
      </div>
    </div>

    <!-- キャプション位置（デフォルト110に変更済み） -->
    <div class="setting-block">
      <label>キャプション位置オフセット（Y方向）</label>
      <div class="input-row">
        <input id="offsetYSlider" type="range" min="-1000" max="1000" step="10" value="110">
        <input id="offsetYInput" type="number" min="-1000" max="1000" step="10" value="110">
      </div>
    </div>

    <!-- 行間 -->
    <div class="setting-block">
      <label>行間（line gap）</label>
      <div class="input-row">
        <input id="lineGapSlider" type="range" min="0.8" max="2.0" step="0.05" value="1.2">
        <input id="lineGapInput" type="number" min="0.5" max="3.0" step="0.05" value="1.2">
      </div>
    </div>

    <!-- フォント（端末依存の自動検出版） -->
    <div class="setting-block">
      <label>フォント</label>
      <select id="fontFamilySelect"></select>
    </div>

    <!-- 文字色 -->
    <div class="setting-block">
      <label>文字色（グレー系）</label>
      <input id="fontColorInput" type="color" value="#9e9e9e">
    </div>

    <!-- 下余白 -->
    <div class="setting-block">
      <label>下余白の追加量（px）</label>
      <input id="extraBottomSlider" type="range" min="0" max="2000" step="10" value="200">
      <input id="extraBottomInput" type="number" min="0" max="2000" step="10" value="200">
    </div>

    <!-- 自由キャプション -->
    <div class="setting-block">
      <label>自由キャプション（複数行可）</label>
      <textarea id="freeCaptionInput" rows="3" style="width:100%;"></textarea>
    </div>

    <!-- 自由キャプションのスタイル -->
    <div class="setting-block">
      <label>自由キャプションのスタイル</label>
      <div class="input-row">
        <label style="display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="freeCaptionItalic"> 斜体
        </label>
        <select id="freeCaptionWeight">
          <option value="300">細め（300）</option>
          <option value="400" selected>標準（400）</option>
          <option value="500">中間（500）</option>
          <option value="700">太め（700）</option>
          <option value="900">極太（900）</option>
        </select>
      </div>
    </div>

    <!-- キャプションと機種名の間隔 -->
    <div class="setting-block">
      <label>キャプションと機種名の間隔（px）</label>
      <input id="captionGapSlider" type="range" min="0" max="300" step="5" value="40">
      <input id="captionGapInput" type="number" min="0" max="300" step="5" value="40">
    </div>

    <!-- キャプション方向 -->
    <div class="setting-block">
      <label>キャプション方向</label>
      <select id="orientationSelect">
        <option value="horizontal">横書き</option>
        <option value="vertical">縦書き（簡易）</option>
      </select>
    </div>

    <!-- 書き出しフォルダ -->
    <div class="setting-block">
      <button id="selectFolderBtn">書き出しフォルダを選択</button>
      <div id="folderStatus" class="status"></div>
    </div>

    <!-- EXIF -->
    <h2>EXIF情報</h2>
    <div class="info" id="exifInfo"></div>

    <!-- 読み込み済み画像 -->
    <h2>読み込み済み画像</h2>
    <div class="thumb-list" id="thumbList"></div>

    <div class="status" id="status"></div>
  </div>

  <!-- 右ペイン -->
  <div class="panel">
    <h2>プレビュー</h2>
    <div class="preview-wrapper">
      <canvas id="previewCanvas"></canvas>
    </div>
  </div>

</div>

<script>
/* ============================
   JavaScript（PC専用・完全版）
============================ */

/* --- グローバル状態 --- */
const state = {
  items: [],
  currentIndex: -1,

  marginRatio: 0.03,
  lineGap: 1.2,
  fontSize: 118,
  fontColor: "#9e9e9e",

  /* ★ デフォルト offsetY を 110 に変更 */
  offsetY: 110,

  extraBottomMargin: 200,
  orientation: "horizontal",

  outputDirHandle: null,

  captionText: "",
  captionGap: 40,

  freeCaptionItalic: false,
  freeCaptionWeight: 400,

  /* フォントは後で自動検出してセットする */
  fontFamily: "",
};

/* --- DOM 取得 --- */
const canvas = document.getElementById("previewCanvas");
const ctx = canvas.getContext("2d");

const dropZone = document.getElementById("dropZone");
const fileInput = document.getElementById("fileInput");

const presetSelect = document.getElementById("presetSelect");

const marginRatioSlider = document.getElementById("marginRatioSlider");
const marginRatioInput = document.getElementById("marginRatioInput");

const lineGapSlider = document.getElementById("lineGapSlider");
const lineGapInput = document.getElementById("lineGapInput");

const fontSizeSlider = document.getElementById("fontSizeSlider");
const fontSizeInput = document.getElementById("fontSizeInput");

const fontColorInput = document.getElementById("fontColorInput");
const fontFamilySelect = document.getElementById("fontFamilySelect");

const offsetYSlider = document.getElementById("offsetYSlider");
const offsetYInput = document.getElementById("offsetYInput");

const extraBottomSlider = document.getElementById("extraBottomSlider");
const extraBottomInput = document.getElementById("extraBottomInput");

const orientationSelect = document.getElementById("orientationSelect");

const freeCaptionInput = document.getElementById("freeCaptionInput");
const captionGapSlider = document.getElementById("captionGapSlider");
const captionGapInput = document.getElementById("captionGapInput");

const freeCaptionItalic = document.getElementById("freeCaptionItalic");
const freeCaptionWeight = document.getElementById("freeCaptionWeight");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const renderCurrentBtn = document.getElementById("renderCurrentBtn");
const renderAllBtn = document.getElementById("renderAllBtn");

const selectFolderBtn = document.getElementById("selectFolderBtn");
const folderStatus = document.getElementById("folderStatus");

const exifInfo = document.getElementById("exifInfo");
const thumbList = document.getElementById("thumbList");
const statusEl = document.getElementById("status");

/* ============================
   フォント自動検出
============================ */

/* チェック候補（OSごとに代表的なフォント） */
const fontCandidates = [
  // Mac
  "Helvetica",
  "Hiragino Sans",
  "Hiragino Kaku Gothic ProN",
  "Yu Gothic",
  "游ゴシック",

  // Windows
  "Yu Gothic UI",
  "Meiryo",
  "MS PGothic",

  // 共通
  "Noto Sans JP",
  "Noto Serif JP",
  "Zen Antique",
  "Zen Old Mincho",
  "Roboto",
  "Arial",
  "Times New Roman",
  "Georgia"
];

/* フォント存在チェック */
async function detectAvailableFonts() {
  const available = [];

  for (const font of fontCandidates) {
    const ok = document.fonts.check(`16px "${font}"`);
    if (ok) available.push(font);
  }

  return available;
}

/* プルダウンに反映 */
async function populateFontSelect() {
  const fonts = await detectAvailableFonts();

  fontFamilySelect.innerHTML = "";

  fonts.forEach(f => {
    const opt = document.createElement("option");
    opt.value = f;
    opt.textContent = f;
    fontFamilySelect.appendChild(opt);
  });

  /* デフォルトフォントの決定 */
  if (fonts.includes("Helvetica")) {
    state.fontFamily = "Helvetica";
  } else if (fonts.includes("Yu Gothic")) {
    state.fontFamily = "Yu Gothic";
  } else {
    state.fontFamily = fonts[0] || "sans-serif";
  }

  fontFamilySelect.value = state.fontFamily;
}

/* ============================
   ユーティリティ
============================ */

function setStatus(msg) {
  statusEl.textContent = msg;
}

function pad2(n) {
  return n.toString().padStart(2, "0");
}

function sanitizeLensName(name) {
  if (!name) return "";
  let s = name.replace(/\x00/g, "");
  s = s.replace(/[\u0000-\u001F]/g, "");
  s = s.replace(/[\(\)\[\]\{\}]/g, "");
  s = s.replace(/[-_\/]+$/g, "");
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

/* ============================
   EXIF パース
============================ */

async function parseExif(file) {
  const buffer = await file.arrayBuffer();
  const view = new DataView(buffer);

  if (view.getUint16(0) !== 0xFFD8) return {};

  let offset = 2;
  while (offset < view.byteLength) {
    const marker = view.getUint16(offset);
    offset += 2;

    if (marker === 0xFFE1) {
      const length = view.getUint16(offset);
      offset += 2;

      if (view.getUint8(offset) === 0x45 && view.getUint8(offset + 1) === 0x78) {
        return parseTiff(view, offset + 6);
      } else {
        offset += length - 2;
      }
    } else {
      offset += view.getUint16(offset);
    }
  }
  return {};
}

function parseTiff(view, offset) {
  const little = view.getUint16(offset) === 0x4949;
  const tiff = offset;
  const firstIFD = view.getUint32(offset + 4, little);

  const exif = {};

  function getIFDEntries(ofs) {
    const num = view.getUint16(tiff + ofs, little);
    const entries = [];
    for (let i = 0; i < num; i++) {
      const eofs = tiff + ofs + 2 + i * 12;
      entries.push({
        tag: view.getUint16(eofs, little),
        type: view.getUint16(eofs + 2, little),
        count: view.getUint32(eofs + 4, little),
        valueOffset: view.getUint32(eofs + 8, little),
        entryOffset: eofs
      });
    }
    const next = view.getUint32(tiff + ofs + 2 + num * 12, little);
    return { entries, next };
  }

  function getValue(e) {
    const { type, count, valueOffset } = e;

    if (type === 2 && count > 1) {
      let s = "";
      const ptr = tiff + valueOffset;
      for (let i = 0; i < count - 1; i++) {
        s += String.fromCharCode(view.getUint8(ptr + i));
      }
      return s;
    }

    if (type === 5) {
      const ptr = tiff + valueOffset;
      const num = view.getUint32(ptr, little);
      const den = view.getUint32(ptr + 4, little);
      return num / den;
    }

    if (type === 3 && count === 1) {
      return view.getUint16(e.entryOffset + 8, little);
    }

    if (type === 4 && count === 1) {
      return valueOffset;
    }

    return null;
  }

  const ifd0 = getIFDEntries(firstIFD);
  let exifIFDOffset = 0;

  for (const e of ifd0.entries) {
    if (e.tag === 0x0110) exif.Model = getValue(e);
    if (e.tag === 0x8769) exifIFDOffset = e.valueOffset;
    if (e.tag === 0xA431) exif.CameraSerialNumber = getValue(e);
  }

  if (exifIFDOffset) {
    const exifIFD = getIFDEntries(exifIFDOffset);
    for (const e of exifIFD.entries) {
      switch (e.tag) {
        case 0x9003:
          exif.DateTimeOriginal = getValue(e);
          break;
        case 0x829A:
          exif.ExposureTime = getValue(e);
          break;
        case 0x829D:
          exif.FFNumberRaw = getValue(e);
          break;
        case 0x8827:
          exif.ISO = getValue(e);
          break;
        case 0xA434:
          exif.LensModel = getValue(e);
          break;
      }
    }
  }

  return exif;
}

/* ============================
   キャプション生成
============================ */
function buildCaptionLines(exif) {
  let model = exif.Model || "UnknownCamera";
  if (model === "DC-G9M2") model = "LUMIX G9Pro2";

  let lens = sanitizeLensName(exif.LensModel || "");
  if (lens.includes("LEICA DG 50-200"))
    lens = "LEICA DG VARIO-ELMARIT 50-200mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("LEICA DG 12-60"))
    lens = "LEICA DG VARIO-ELMARIT 12-60mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("OLYMPUS M.300mm F4.0"))
    lens = "M.ZUIKO DIGITAL ED 300mm F4.0 IS PRO";

  let dt = "";
  if (exif.DateTimeOriginal) {
    const [d, t] = exif.DateTimeOriginal.split(" ");
    const [Y, M, D] = d.split(":");
    const [h, m] = t.split(":");
    dt = `${Y}/${M}/${D}  ${h}:${m}`;
  } else {
    dt = "----/--/--  --:--";
  }

  let ss = "";
  if (exif.ExposureTime) {
    if (exif.ExposureTime >= 1) {
      ss = `SS：${exif.ExposureTime.toFixed(1).replace(/\.0$/, "")}s`;
    } else {
      const d = Math.round(1 / exif.ExposureTime);
      ss = `SS：1/${d}s`;
    }
  } else ss = "SS：?";

  let f = exif.FNumberRaw
    ? `F/${exif.FNumberRaw.toFixed(1).replace(/\.0$/, "")}`
    : "F/?";

  const iso = exif.ISO ? `ISO${exif.ISO}` : "ISO?";

  const line1 = `${model}　LENS：${lens}`;
  const line2 = `${dt}　　${ss}　${f}　${iso}`;

  return [line1, line2];
}

/* ============================
   画像読み込み
============================ */
async function loadFiles(files) {
  const list = [...files].filter(f => /^image\/(jpeg|jpg|png)$/i.test(f.type));
  if (list.length === 0) {
    setStatus("JPEG/PNG 以外は無視されました");
    return;
  }

  setStatus(`${list.length} 件読み込み中…`);

  for (const file of list) {
    try {
      const exif = await parseExif(file);
      const img = await loadImageBitmap(file);
      const captionLines = buildCaptionLines(exif);
      const outputName = buildOutputFilename(exif);

      state.items.push({
        file,
        img,
        width: img.width,
        height: img.height,
        exif,
        captionLines,
        outputName
      });
    } catch (e) {
      console.error(e);
      setStatus(`"${file.name}" の読み込みでエラー`);
    }
  }

  state.currentIndex = state.items.length - 1;

  setStatus("読み込み完了");
  updateView();
}

function loadImageBitmap(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = err => {
      URL.revokeObjectURL(url);
      reject(err);
    };
    img.src = url;
  });
}

/* ============================
   ファイル名生成
============================ */
function buildOutputFilename(exif) {
  let ymd = "";
  let hms = "";

  if (exif.DateTimeOriginal) {
    const [d, t] = exif.DateTimeOriginal.split(" ");
    const [Y, M, D] = d.split(":");
    const [h, m, s] = t.split(":");
    ymd = `${Y}${M}${D}`;
    hms = `${h}${m}${s}`;
  } else {
    const d = new Date();
    ymd = `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
    hms = `${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
  }

  const lens = sanitizeLensName(exif.LensModel || "Lens");
  const serial = exif.CameraSerialNumber || "NOSERIAL";

  return `${ymd}_${hms}_${lens}_${serial}.jpg`;
}

/* ============================
   描画処理
============================ */
function drawCurrent() {
  if (state.currentIndex < 0) return;
  const item = state.items[state.currentIndex];
  const img = item.img;

  const shortSide = Math.min(img.width, img.height);
  const margin = Math.round(shortSide * state.marginRatio);

  const captionHeight = state.fontSize * (1 + state.lineGap);
  const marginBottom = state.extraBottomMargin + captionHeight;

  canvas.width = img.width + margin * 2;
  canvas.height = img.height + margin + marginBottom;

  ctx.fillStyle = "#FFFFFF";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.drawImage(img, margin, margin);

  const [line1, line2] = item.captionLines;

  const bottomAreaTop = img.height + margin;
  const bottomAreaBottom = canvas.height;
  const bottomAreaCenterY = (bottomAreaTop + bottomAreaBottom) / 2;

  let baseY = bottomAreaCenterY + state.offsetY;
  const centerX = canvas.width / 2;

  ctx.textAlign = "center";
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = state.fontColor;

  /* --- 自由キャプション --- */
  if (state.captionText.trim() !== "") {
    const freeLines = state.captionText.split(/\r?\n/);

    const italic = state.freeCaptionItalic ? "italic " : "";
    const weight = state.freeCaptionWeight || 400;

    ctx.font = `${italic}${weight} ${state.fontSize}px "${state.fontFamily}", sans-serif`;

    baseY -= (freeLines.length * state.fontSize * state.lineGap);

    for (const line of freeLines) {
      ctx.fillText(line, centerX, baseY);
      baseY += state.fontSize * state.lineGap;
    }

    baseY += state.captionGap;
  }

  /* --- line1（太字） --- */
  ctx.font = `700 ${state.fontSize}px "${state.fontFamily}", sans-serif`;
  ctx.fillText(line1, centerX, baseY - state.fontSize * state.lineGap);

  /* --- line2（通常） --- */
  ctx.font = `400 ${state.fontSize}px "${state.fontFamily}", sans-serif`;
  ctx.fillText(line2, centerX, baseY);
}

/* ============================
   書き出し
============================ */
async function saveToFolder(filename, blob) {
  if (!state.outputDirHandle) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 2000);
    return;
  }

  const fileHandle = await state.outputDirHandle.getFileHandle(filename, { create: true });
  const writable = await fileHandle.createWritable();
  await writable.write(blob);
  await writable.close();
}

function downloadCanvas(filename) {
  return new Promise(resolve => {
    canvas.toBlob(async (blob) => {
      await saveToFolder(filename, blob);
      resolve();
    }, "image/jpeg", 0.95);
  });
}

/* ============================
   UI 更新
============================ */
function refreshThumbList() {
  thumbList.innerHTML = "";
  state.items.forEach((item, i) => {
    const div = document.createElement("div");
    div.className = "thumb-item" + (i === state.currentIndex ? " active" : "");
    div.textContent = item.file.name;
    div.onclick = () => {
      state.currentIndex = i;
      updateView();
    };
    thumbList.appendChild(div);
  });
}

function updateExifInfo() {
  exifInfo.innerHTML = "";
  if (state.currentIndex < 0 || state.currentIndex >= state.items.length) return;

  const item = state.items[state.currentIndex];
  const exif = item.exif;

  let model = exif.Model || "(不明)";
  if (model === "DC-G9M2") model = "LUMIX G9Pro2";

  let lens = sanitizeLensName(exif.LensModel || "");
  if (lens.includes("LEICA DG 50-200"))
    lens = "LEICA DG VARIO-ELMARIT 50-200mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("LEICA DG 12-60"))
    lens = "LEICA DG VARIO-ELMARIT 12-60mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("OLYMPUS M.300mm F4.0"))
    lens = "M.ZUIKO DIGITAL ED 300mm F4.0 IS PRO";
  if (!lens) lens = "(不明)";

  function add(label, value) {
    const div = document.createElement("div");
    div.textContent = `${label}: ${value}`;
    exifInfo.appendChild(div);
  }

  add("ファイル名", item.file.name);
  add("解像度", `${item.width} × ${item.height}`);
  add("DateTimeOriginal", exif.DateTimeOriginal || "(なし)");
  add("CAMERA", model);
  add("LENS", lens);
  add("CameraSerialNumber", exif.CameraSerialNumber || "(不明)");
  add("出力ファイル名", item.outputName);
}

function updateView() {
  refreshThumbList();
  updateExifInfo();
  drawCurrent();
}

/* ============================
   プリセット
============================ */
presetSelect.onchange = async () => {
  const p = presetSelect.value;

  if (p === "g9m2") {
    state.marginRatio = 0.03;
    state.lineGap = 1.55;
    state.fontSize = 112;
    state.fontFamily = "Zen Antique";
    state.fontColor = "#9e9e9e";
    state.offsetY = 90;
    state.extraBottomMargin = 470;
    state.captionGap = 40;
  }

  if (p === "v1") {
    state.marginRatio = 0.03;
    state.lineGap = 1.5;
    state.fontSize = 114;
    state.fontFamily = "Zen Antique";
    state.fontColor = "#9e9e9e";
    state.offsetY = 80;
    state.extraBottomMargin = 600;
    state.captionGap = 40;
  }

  if (p === "none") return;

  marginRatioSlider.value = state.marginRatio;
  marginRatioInput.value = state.marginRatio;
  lineGapSlider.value = state.lineGap;
  lineGapInput.value = state.lineGap;
  fontSizeSlider.value = state.fontSize;
  fontSizeInput.value = state.fontSize;
  fontFamilySelect.value = state.fontFamily;
  fontColorInput.value = state.fontColor;
  offsetYSlider.value = state.offsetY;
  offsetYInput.value = state.offsetY;
  extraBottomSlider.value = state.extraBottomMargin;
  extraBottomInput.value = state.extraBottomMargin;
  captionGapSlider.value = state.captionGap;
  captionGapInput.value = state.captionGap;

  await document.fonts.load(`${state.fontSize}px "${state.fontFamily}"`);
  drawCurrent();
};

/* ============================
   UIイベント
============================ */
marginRatioSlider.oninput = () => {
  state.marginRatio = Number(marginRatioSlider.value);
  marginRatioInput.value = state.marginRatio;
  drawCurrent();
};

marginRatioInput.oninput = () => {
  state.marginRatio = Number(marginRatioInput.value);
  marginRatioSlider.value = state.marginRatio;
  drawCurrent();
};

lineGapSlider.oninput = () => {
  state.lineGap = Number(lineGapSlider.value);
  lineGapInput.value = state.lineGap;
  drawCurrent();
};

lineGapInput.oninput = () => {
  state.lineGap = Number(lineGapInput.value);
  lineGapSlider.value = state.lineGap;
  drawCurrent();
};

fontSizeSlider.oninput = () => {
  state.fontSize = Number(fontSizeSlider.value);
  fontSizeInput.value = state.fontSize;
  drawCurrent();
};

fontSizeInput.oninput = e => {
  state.fontSize = Number(e.target.value);
  fontSizeSlider.value = state.fontSize;
  drawCurrent();
};

fontColorInput.oninput = e => {
  state.fontColor = e.target.value;
  drawCurrent();
};

fontFamilySelect.onchange = async e => {
  state.fontFamily = e.target.value;
  await document.fonts.load(`${state.fontSize}px "${state.fontFamily}"`);
  drawCurrent();
};

offsetYSlider.oninput = () => {
  state.offsetY = Number(offsetYSlider.value);
  offsetYInput.value = state.offsetY;
  drawCurrent();
};

offsetYInput.oninput = e => {
  state.offsetY = Number(e.target.value);
  offsetYSlider.value = state.offsetY;
  drawCurrent();
};

extraBottomSlider.oninput = () => {
  state.extraBottomMargin = Number(extraBottomSlider.value);
  extraBottomInput.value = state.extraBottomMargin;
  drawCurrent();
};

extraBottomInput.oninput = () => {
  state.extraBottomMargin = Number(extraBottomInput.value);
  extraBottomSlider.value = state.extraBottomMargin;
  drawCurrent();
};

orientationSelect.onchange = e => {
  state.orientation = e.target.value;
  drawCurrent();
};

freeCaptionInput.oninput = e => {
  state.captionText = e.target.value;
  drawCurrent();
};

captionGapSlider.oninput = () => {
  state.captionGap = Number(captionGapSlider.value);
  captionGapInput.value = state.captionGap;
  drawCurrent();
};

captionGapInput.oninput = () => {
  state.captionGap = Number(captionGapInput.value);
  captionGapSlider.value = state.captionGap;
  drawCurrent();
};

freeCaptionItalic.onchange = e => {
  state.freeCaptionItalic = e.target.checked;
  drawCurrent();
};

freeCaptionWeight.onchange = e => {
  state.freeCaptionWeight = Number(e.target.value);
  drawCurrent();
};

/* ============================
   書き出しフォルダ選択
============================ */
selectFolderBtn.onclick = async () => {
  try {
    const handle = await window.showDirectoryPicker();
    state.outputDirHandle = handle;
    folderStatus.textContent = "選択済み：" + handle.name;
  } catch (e) {
    folderStatus.textContent = "フォルダ選択がキャンセルされました";
  }
};

/* ============================
   ナビゲーション
============================ */
prevBtn.onclick = () => {
  if (state.items.length === 0) return;
  state.currentIndex = (state.currentIndex - 1 + state.items.length) % state.items.length;
  updateView();
};

nextBtn.onclick = () => {
  if (state.items.length === 0) return;
  state.currentIndex = (state.currentIndex + 1) % state.items.length;
  updateView();
};

/* ============================
   書き出し
============================ */
renderCurrentBtn.onclick = async () => {
  if (state.currentIndex < 0) return;
  drawCurrent();
  const item = state.items[state.currentIndex];
  await downloadCanvas(item.outputName);
  setStatus(`"${item.outputName}" を書き出しました`);
};

renderAllBtn.onclick = async () => {
  if (state.items.length === 0) return;
  setStatus("一括書き出し中…");

  for (let i = 0; i < state.items.length; i++) {
    state.currentIndex = i;
    drawCurrent();
    const item = state.items[i];
    await downloadCanvas(item.outputName);
  }

  updateView();
  setStatus("一括書き出し完了");
};

/* ============================
   ドロップゾーン
============================ */
dropZone.onclick = () => fileInput.click();

dropZone.ondragover = e => {
  e.preventDefault();
  dropZone.classList.add("dragover");
};

dropZone.ondragleave = () => dropZone.classList.remove("dragover");

dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove("dragover");
  loadFiles(e.dataTransfer.files);
};

fileInput.onchange = e => {
  loadFiles(e.target.files);
  fileInput.value = "";
};

/* ============================
   初期化
============================ */
(async () => {
  await populateFontSelect();
  setStatus("画像を読み込んでください");
})();
</script>

</body>
</html>
