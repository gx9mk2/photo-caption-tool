<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8"> 
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<title>写真キャプション合成ツール（1ファイル版）</title>

<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@400;700&family=Shippori+Mincho:wght@400;700&family=Yuji+Boku&family=Yuji+Mai&family=Yuji+Syuku&family=Zen+Old+Mincho:wght@400;700&family=Zen+Antique&family=Zen+Antique+Soft&family=Sawarabi+Mincho&display=swap" rel="stylesheet">

<style>
/* ▼ ここからCSS全部 ▼ */

body {
  margin: 0;
  padding: 16px;
  background: #111;
  color: #eee;
  font-family: "Zen Antique", "Noto Sans JP", "Yu Gothic", "游ゴシック", sans-serif;
}

h1 {
  margin: 0 0 12px;
  font-size: 20px;
}

.container {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 16px;
}

.panel {
  background: #181818;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 12px;
}

.panel h2 {
  margin: 0 0 8px;
  font-size: 14px;
  border-bottom: 1px solid #333;
  padding-bottom: 4px;
}

#dropZone {
  border: 2px dashed #666;
  border-radius: 8px;
  padding: 16px;
  text-align: center;
  color: #ccc;
  margin-bottom: 8px;
  cursor: pointer;
}

#dropZone.dragover {
  border-color: #4fc3f7;
  background: rgba(79,195,247,0.05);
}

input, select, button, textarea {
  font-family: inherit;
  font-size: 12px;
}

button {
  padding: 6px 10px;
  border: 1px solid #555;
  background: #333;
  color: #eee;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #444;
}

button:disabled {
  opacity: 0.4;
  cursor: default;
}

.btn-row {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin: 6px 0;
}

.setting-block {
  margin: 10px 0;
  font-size: 12px;
}

/* ラベル */
.setting-block label {
  display: block;
  margin-bottom: 4px;
}

/* ▼ 旧range幅（上書きされるので残してOK） */
.setting-block input[type="range"] {
  width: 100%;
  margin-bottom: 4px;
}

/* 情報欄 */
.info {
  font-size: 11px;
  color: #aaa;
  max-height: 160px;
  overflow-y: auto;
}

.thumb-list {
  max-height: 200px;
  overflow-y: auto;
  font-size: 11px;
}

.thumb-item {
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
}

.thumb-item.active {
  background: #2e7d32;
}

.thumb-item:hover {
  background: #333;
}

.preview-wrapper {
  border: 1px solid #333;
  border-radius: 8px;
  height: calc(100vh - 80px);
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  background: #000;
}

.status {
  font-size: 11px;
  color: #aaa;
  margin-top: 4px;
}

/* ▼ 横並びレイアウト（今回のUI整理で必要） */
.setting-block {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.setting-block .input-row {
  display: flex;
  gap: 6px;
  align-items: center;
}

.setting-block .input-row input[type="range"] {
  flex: 1;
}

.setting-block .input-row input[type="number"] {
  width: 80px;
}

/* ============================
   スマホ最適化（幅768px以下）
   ============================ */
@media (max-width: 768px) {

  body {
    padding: 8px;
  }

  h1 {
    font-size: 16px;
    margin-bottom: 8px;
  }

  .container {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  /* 画像を中央に大きく表示 */
  #previewCanvas {
    max-width: 100%;
    height: auto;
    margin: 0 auto;
    display: block;
  }

  /* PC用パネルは非表示 */
  .panel {
    display: none !important;
  }

  /* プレビューだけ表示するための簡易ラッパ */
  .preview-wrapper {
    height: auto;
    min-height: 50vh;
  }

  /* 下部ツールバー */
  .mobile-toolbar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #222;
    padding: 10px 0;
    display: flex;
    justify-content: space-around;
    border-top: 1px solid #444;
    z-index: 1000;
  }

  .mobile-toolbar button {
    background: none;
    border: none;
    color: #eee;
    font-size: 13px;
    font-weight: 600;
    padding: 6px 4px;
    letter-spacing: 0.5px;
  }

  .mobile-toolbar button:active {
    opacity: 0.6;
  }

  /* スライドアップパネル */
  .mobile-panel {
    display: none;
    position: fixed;
    bottom: 60px; /* ツールバーの高さ分 */
    left: 0;
    right: 0;
    background: #181818;
    padding: 16px;
    border-top: 1px solid #333;
    z-index: 1000;
  }

  .mobile-panel.open {
    display: block;
  }

  .mobile-panel h3 {
    margin: 0 0 12px;
    font-size: 16px;
    color: #fff;
  }

  .mobile-panel input[type="range"] {
    width: 100%;
    margin: 8px 0 16px;
  }

  .mobile-panel label {
    font-size: 14px;
    color: #ccc;
  }

  .value-display {
    font-size: 14px;
    color: #aaa;
    margin-top: -8px;
    margin-bottom: 12px;
  }

  .pos-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }

  .pos-grid button {
    padding: 12px 0;
    font-size: 20px;
    background: #222;
    border: 1px solid #444;
    border-radius: 6px;
    color: #eee;
  }

  .pos-grid button:active {
    background: #333;
  }
}

/* ▲ CSSここまで ▲ */
</style>

</head>

<body>

<h1>写真キャプション合成ツール（1ファイル版）</h1>

<div class="container">

  <!-- 左ペイン -->
  <div class="panel">
    <h2>画像読み込み</h2>

    <div id="dropZone">ここに画像をドロップ<br>またはクリックして選択</div>
    <input id="fileInput" type="file" accept="image/jpeg,image/png" multiple>

    <!-- プリセット -->
    <div class="setting-block">
      <label>プリセット</label>
      <div class="input-row">
        <select id="presetSelect">
          <option value="none" selected>選択してください</option>
          <option value="g9m2">LUMIX G9M2 用</option>
          <option value="v1">PowerShot V1 用</option>
        </select>
      </div>
    </div>

    <!-- 余白比率（上・左右） -->
    <div class="setting-block">
      <label>余白比率（上・左右）</label>
      <div class="input-row">
        <input id="marginRatioSlider" type="range" min="0" max="0.20" step="0.01" value="0.03">
        <input id="marginRatioInput" type="number" min="0" max="1" step="0.01" value="0.03">
      </div>
    </div>

    <!-- フォントサイズ -->
    <div class="setting-block">
      <label>フォントサイズ</label>
      <div class="input-row">
        <input id="fontSizeSlider" type="range" min="8" max="300" step="1" value="118">
        <input id="fontSizeInput" type="number" min="8" max="300" step="1" value="118">
      </div>
    </div>

    <!-- キャプション位置オフセット（Y方向） -->
    <div class="setting-block">
      <label>キャプション位置オフセット（Y方向・マイナス可）</label>
      <div class="input-row">
        <input id="offsetYSlider" type="range" min="-1000" max="1000" step="10" value="0">
        <input id="offsetYInput" type="number" value="0" min="-1000" max="1000" step="10">
      </div>
    </div>

    <!-- 行間 -->
    <div class="setting-block">
      <label>行間（line gap）</label>
      <div class="input-row">
        <input id="lineGapSlider" type="range" min="0.8" max="2.0" step="0.05" value="1.2">
        <input id="lineGapInput" type="number" min="0.5" max="3.0" step="0.05" value="1.2">
      </div>
    </div>

    <!-- フォント選択 -->
    <div class="setting-block">
      <label>フォント</label>
      <select id="fontFamilySelect">
        <option value="Zen Antique" selected>Zen Antique（デフォルト）</option>
        <option value="Noto Sans JP">Noto Sans JP</option>
        <option value="BIZ UDMincho">BIZ UDMincho</option>
        <option value="BIZ UDPMincho">BIZ UDPMincho</option>
        <option value="Shippori Mincho B1">Shippori Mincho B1</option>
        <option value="Noto Serif JP">Noto Serif JP</option>
        <option value="Shippori Mincho">Shippori Mincho</option>
        <option value="Yuji Syuku">Yuji Syuku</option>
        <option value="Zen Old Mincho">Zen Old Mincho</option>
        <option value="Zen Antique Soft">Zen Antique Soft</option>
        <option value="Sawarabi Mincho">Sawarabi Mincho</option>
        <option value="Yu Gothic">Yu Gothic</option>
        <option value="游ゴシック">游ゴシック</option>
        <option value="Meiryo">メイリオ</option>
        <option value="Hiragino Sans">Hiragino Sans</option>
        <option value="Roboto">Roboto</option>
      </select>
    </div>

    <!-- 文字色 -->
    <div class="setting-block">
      <label>文字色（グレー系）</label>
      <input id="fontColorInput" type="color" value="#9e9e9e">
    </div>

    <!-- 下余白の追加量 -->
    <div class="setting-block">
      <label>下余白の追加量（px）</label>
      <input id="extraBottomSlider" type="range" min="0" max="2000" step="10" value="200">
      <input id="extraBottomInput" type="number" min="0" max="2000" step="10" value="200">
    </div>

    <!-- ★ 自由キャプション（複数行可） -->
    <div class="setting-block">
      <label>自由キャプション（複数行可）</label>
      <textarea id="freeCaptionInput" rows="3" style="width:100%;"></textarea>
    </div>

    <!-- ★ 自由キャプションのスタイル（斜体・ウェイト） -->
    <div class="setting-block">
      <label>自由キャプションのスタイル</label>
      <div class="input-row">
        <label style="display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="freeCaptionItalic"> 斜体
        </label>

        <select id="freeCaptionWeight">
          <option value="300">細め（300）</option>
          <option value="400" selected>標準（400）</option>
          <option value="500">中間（500）</option>
          <option value="700">太め（700）</option>
          <option value="900">極太（900）</option>
        </select>
      </div>
    </div>

    <!-- ★ 自由キャプションと機種名の間隔（追加） -->
    <div class="setting-block">
      <label>キャプションと機種名の間隔（px）</label>
      <input id="captionGapSlider" type="range" min="0" max="300" step="5" value="40">
      <input id="captionGapInput" type="number" min="0" max="300" step="5" value="40">
    </div>

    <!-- キャプション方向 -->
    <div class="setting-block">
      <label>キャプション方向</label>
      <select id="orientationSelect">
        <option value="horizontal">横書き</option>
        <option value="vertical">縦書き（簡易）</option>
      </select>
    </div>

    <!-- 書き出しフォルダ選択 -->
    <div class="setting-block">
      <button id="selectFolderBtn">書き出しフォルダを選択</button>
      <div id="folderStatus" class="status"></div>
    </div>

    <!-- ボタン -->
    <div class="btn-row">
      <button id="prevBtn">前へ</button>
      <button id="nextBtn">次へ</button>
      <button id="renderCurrentBtn">現在を書き出し</button>
      <button id="renderAllBtn">全て書き出し</button>
    </div>

    <!-- EXIF 情報 -->
    <h2>EXIF情報</h2>
    <div class="info" id="exifInfo"></div>

    <!-- 読み込み済み画像 -->
    <h2>読み込み済み画像</h2>
    <div class="thumb-list" id="thumbList"></div>

    <div class="status" id="status"></div>
  </div>

  <!-- 右ペイン -->
  <div class="panel">
    <h2>プレビュー</h2>
    <div class="preview-wrapper">
      <canvas id="previewCanvas"></canvas>
    </div>
  </div>

</div>

<!-- ▼ スマホ用：下部ツールバー -->
<div class="mobile-toolbar">
  <button data-panel="font">FONT</button>
  <button data-panel="size">SIZE</button>
  <button data-panel="pos">POS</button>
  <button data-panel="margin">MARGIN</button>
</div>

<!-- ▼ スマホ用：スライドアップパネル群 -->
<div id="panel-font" class="mobile-panel">
  <h3>Font</h3>
  <select id="mobileFontFamilySelect">
    <option value="Zen Antique">Zen Antique</option>
    <option value="Noto Sans JP">Noto Sans JP</option>
    <option value="BIZ UDMincho">BIZ UDMincho</option>
    <option value="BIZ UDPMincho">BIZ UDPMincho</option>
    <option value="Shippori Mincho B1">Shippori Mincho B1</option>
    <option value="Noto Serif JP">Noto Serif JP</option>
    <option value="Shippori Mincho">Shippori Mincho</option>
    <option value="Yuji Syuku">Yuji Syuku</option>
    <option value="Zen Old Mincho">Zen Old Mincho</option>
    <option value="Zen Antique Soft">Zen Antique Soft</option>
    <option value="Sawarabi Mincho">Sawarabi Mincho</option>
    <option value="Yu Gothic">Yu Gothic</option>
    <option value="游ゴシック">游ゴシック</option>
    <option value="Meiryo">メイリオ</option>
    <option value="Hiragino Sans">Hiragino Sans</option>
    <option value="Roboto">Roboto</option>
  </select>
</div>

<div id="panel-size" class="mobile-panel">
  <h3>Size</h3>
  <input type="range" id="mobileFontSizeSlider" min="8" max="300" step="1" value="118">
  <div class="value-display" id="mobileFontSizeValue">118px</div>
</div>

<div id="panel-pos" class="mobile-panel">
  <h3>Position (Y offset)</h3>
  <input type="range" id="mobileOffsetYSlider" min="-1000" max="1000" step="10" value="0">
  <div class="value-display" id="mobileOffsetYValue">0</div>
</div>

<div id="panel-margin" class="mobile-panel">
  <h3>Margin</h3>

  <label>余白比率（上・左右）</label>
  <input type="range" id="mobileMarginRatioSlider" min="0" max="0.20" step="0.01" value="0.03">
  <div class="value-display" id="mobileMarginRatioValue">0.03</div>

  <label>下余白の追加量（px）</label>
  <input type="range" id="mobileExtraBottomSlider" min="0" max="2000" step="10" value="200">
  <div class="value-display" id="mobileExtraBottomValue">200px</div>

  <label>キャプションと機種名の間隔（px）</label>
  <input type="range" id="mobileCaptionGapSlider" min="0" max="300" step="5" value="40">
  <div class="value-display" id="mobileCaptionGapValue">40px</div>
</div>

<script>
/* ==========================
   グローバル状態
========================== */
const state = {
  items: [],
  currentIndex: -1,

  // 上・左右の余白比率
  marginRatio: 0.03,

  // 行間
  lineGap: 1.2,

  // フォント設定
  fontSize: 118,
  fontColor: "#9e9e9e",
  fontFamily: "Noto Sans JP",

  // キャプション位置オフセット（下余白中央を基準）
  offsetY: 0,

  // 下余白の追加量
  extraBottomMargin: 200,

  // キャプション方向
  orientation: "horizontal",

  // 書き出しフォルダ
  outputDirHandle: null,

  // ★ 自由キャプション（追加）
  captionText: "",

  // ★ 自由キャプションと機種名の間隔（追加）
  captionGap: 40,

  // ★ 自由キャプションのスタイル（追加）
  freeCaptionItalic: false,
  freeCaptionWeight: 400,
};

const canvas = document.getElementById("previewCanvas");
const ctx = canvas.getContext("2d");

const dropZone = document.getElementById("dropZone");
const fileInput = document.getElementById("fileInput");

const presetSelect = document.getElementById("presetSelect");

const marginRatioSlider = document.getElementById("marginRatioSlider");
const marginRatioInput = document.getElementById("marginRatioInput");

const lineGapSlider = document.getElementById("lineGapSlider");
const lineGapInput = document.getElementById("lineGapInput");

const fontSizeSlider = document.getElementById("fontSizeSlider");
const fontSizeInput = document.getElementById("fontSizeInput");
const fontColorInput = document.getElementById("fontColorInput");
const fontFamilySelect = document.getElementById("fontFamilySelect");

const offsetYSlider = document.getElementById("offsetYSlider");
const offsetYInput = document.getElementById("offsetYInput");

const extraBottomSlider = document.getElementById("extraBottomSlider");
const extraBottomInput = document.getElementById("extraBottomInput");

const orientationSelect = document.getElementById("orientationSelect");

const freeCaptionInput = document.getElementById("freeCaptionInput");
const captionGapSlider = document.getElementById("captionGapSlider");
const captionGapInput = document.getElementById("captionGapInput");
const freeCaptionItalic = document.getElementById("freeCaptionItalic");
const freeCaptionWeight = document.getElementById("freeCaptionWeight");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const renderCurrentBtn = document.getElementById("renderCurrentBtn");
const renderAllBtn = document.getElementById("renderAllBtn");

const selectFolderBtn = document.getElementById("selectFolderBtn");
const folderStatus = document.getElementById("folderStatus");

const exifInfo = document.getElementById("exifInfo");
const thumbList = document.getElementById("thumbList");
const statusEl = document.getElementById("status");

/* ==========================
   ユーティリティ
========================== */
function setStatus(msg) {
  statusEl.textContent = msg;
}

function pad2(n) {
  return n.toString().padStart(2, "0");
}

function sanitizeLensName(name) {
  if (!name) return "";
  let s = name.replace(/\x00/g, "");
  s = s.replace(/[\u0000-\u001F]/g, "");
  s = s.replace(/[\(\)\[\]\{\}]/g, "");
  s = s.replace(/[-_\/]+$/g, "");
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

/* ==========================
   EXIF パース
========================== */
async function parseExif(file) {
  const buffer = await file.arrayBuffer();
  const view = new DataView(buffer);

  if (view.getUint16(0) !== 0xFFD8) return {};

  let offset = 2;
  while (offset < view.byteLength) {
    const marker = view.getUint16(offset);
    offset += 2;

    if (marker === 0xFFE1) {
      const length = view.getUint16(offset);
      offset += 2;

      if (view.getUint8(offset) === 0x45 && view.getUint8(offset + 1) === 0x78) {
        return parseTiff(view, offset + 6);
      } else {
        offset += length - 2;
      }
    } else {
      offset += view.getUint16(offset);
    }
  }
  return {};
}

function parseTiff(view, offset) {
  const byteOrder = view.getUint16(offset);
  const little = byteOrder === 0x4949;
  const tiff = offset;
  const firstIFD = view.getUint32(offset + 4, little);

  const exif = {};

  function getIFDEntries(ofs) {
    const num = view.getUint16(tiff + ofs, little);
    const entries = [];
    for (let i = 0; i < num; i++) {
      const eofs = tiff + ofs + 2 + i * 12;
      entries.push({
        tag: view.getUint16(eofs, little),
        type: view.getUint16(eofs + 2, little),
        count: view.getUint32(eofs + 4, little),
        valueOffset: view.getUint32(eofs + 8, little),
        entryOffset: eofs
      });
    }
    const next = view.getUint32(tiff + ofs + 2 + num * 12, little);
    return { entries, next };
  }

  function getValue(e) {
    const { type, count, valueOffset } = e;
    if (type === 2 && count > 1) {
      let s = "";
      const ptr = tiff + valueOffset;
      for (let i = 0; i < count - 1; i++) {
        s += String.fromCharCode(view.getUint8(ptr + i));
      }
      return s;
    }
    if (type === 5) {
      const ptr = tiff + valueOffset;
      const num = view.getUint32(ptr, little);
      const den = view.getUint32(ptr + 4, little);
      return num / den;
    }
    if (type === 3 && count === 1) {
      return view.getUint16(e.entryOffset + 8, little);
    }
    if (type === 4 && count === 1) {
      return valueOffset;
    }
    return null;
  }

  const ifd0 = getIFDEntries(firstIFD);
  let exifIFDOffset = 0;

  for (const e of ifd0.entries) {
    if (e.tag === 0x0110) exif.Model = getValue(e);
    if (e.tag === 0x8769) exifIFDOffset = e.valueOffset;
    if (e.tag === 0xA431) exif.CameraSerialNumber = getValue(e);
  }

  if (exifIFDOffset) {
    const exifIFD = getIFDEntries(exifIFDOffset);
    for (const e of exifIFD.entries) {
      switch (e.tag) {
        case 0x9003:
          exif.DateTimeOriginal = getValue(e);
          break;
        case 0x829A:
          exif.ExposureTime = getValue(e);
          break;
        case 0x829D:
          exif.FNumberRaw = getValue(e);
          break;
        case 0x8827:
          exif.ISO = getValue(e);
          break;
        case 0xA434:
          exif.LensModel = getValue(e);
          break;
        case 0xA431:
          if (!exif.CameraSerialNumber) exif.CameraSerialNumber = getValue(e);
          break;
      }
    }
  }

  return exif;
}

/* ==========================
   キャプション生成
========================== */
function buildCaptionLines(exif) {
  let model = exif.Model || "UnknownCamera";
  if (model === "DC-G9M2") model = "LUMIX G9Pro2";

  let lens = sanitizeLensName(exif.LensModel || "");
  if (lens.includes("LEICA DG50-200"))
    lens = "LEICA DG VARIO-ELMARIT 50-200mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("LEICA DG12-60"))
    lens = "LEICA DG VARIO-ELMARIT 12-60mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("OLYMPUS M.300mm F4.0"))
    lens = "M.ZUIKO DIGITAL ED 300mm F4.0 IS PRO";

  let dt = "";
  if (exif.DateTimeOriginal) {
    const [d, t] = exif.DateTimeOriginal.split(" ");
    const [Y, M, D] = d.split(":");
    const [h, m] = t.split(":");
    dt = `${Y}/${M}/${D}  ${h}:${m}`;
  } else {
    dt = "----/--/--  --:--";
  }

  let ss = "";
  if (exif.ExposureTime) {
    if (exif.ExposureTime >= 1) {
      ss = `SS：${exif.ExposureTime.toFixed(1).replace(/\.0$/, "")}s`;
    } else {
      const d = Math.round(1 / exif.ExposureTime);
      ss = `SS：1/${d}s`;
    }
  } else ss = "SS：?";

  let f = exif.FNumberRaw
    ? `F/${exif.FNumberRaw.toFixed(1).replace(/\.0$/, "")}`
    : "F/?";

  const iso = exif.ISO ? `ISO${exif.ISO}` : "ISO?";

  let line1 = `${model}`;
  if (lens) line1 += `　LENS：${lens}`;

  const line2 = `${dt}　　${ss}　${f}　${iso}`;

  return [line1, line2];
}

/* ==========================
   画像読み込み
========================== */
async function loadFiles(files) {
  const list = [...files].filter(f => /^image\/(jpeg|jpg|png)$/i.test(f.type));
  if (list.length === 0) {
    setStatus("JPEG/PNG 以外は無視されました");
    return;
  }

  setStatus(`${list.length} 件読み込み中…`);

  for (const file of list) {
    try {
      const exif = await parseExif(file);
      const img = await loadImageBitmap(file);
      const captionLines = buildCaptionLines(exif);
      const outputName = buildOutputFilename(exif);

      state.items.push({
        file,
        img,
        width: img.width,
        height: img.height,
        exif,
        captionLines,
        outputName
      });
    } catch (e) {
      console.error(e);
      setStatus(`"${file.name}" の読み込みでエラー`);
    }
  }

  state.currentIndex = state.items.length - 1;

  setStatus("読み込み完了");
  updateView();
}

function loadImageBitmap(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = err => {
      URL.revokeObjectURL(url);
      reject(err);
    };
    img.src = url;
  });
}

/* ==========================
   ファイル名生成
========================== */
function buildOutputFilename(exif) {
  let ymd = "";
  let hms = "";

  if (exif.DateTimeOriginal) {
    const [d, t] = exif.DateTimeOriginal.split(" ");
    const [Y, M, D] = d.split(":");
    const [h, m, s] = t.split(":");
    ymd = `${Y}${M}${D}`;
    hms = `${h}${m}${s}`;
  } else {
    const d = new Date();
    ymd = `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
    hms = `${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
  }

  const lens = sanitizeLensName(exif.LensModel || "Lens");
  const serial = exif.CameraSerialNumber || "NOSERIAL";

  return `${ymd}_${hms}_${lens}_${serial}.jpg`;
}

/* ==========================
   描画処理（自由キャプション統合版）
========================== */
function drawCurrent() {
  if (state.currentIndex < 0) return;
  const item = state.items[state.currentIndex];
  const img = item.img;

  const shortSide = Math.min(img.width, img.height);

  const margin = Math.round(shortSide * state.marginRatio);

  const captionHeight = state.fontSize * (1 + state.lineGap);

  const marginBottom = state.extraBottomMargin + captionHeight;

  canvas.width = img.width + margin * 2;
  canvas.height = img.height + margin + marginBottom;

  ctx.fillStyle = "#FFFFFF";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.drawImage(img, margin, margin);

  const [line1, line2] = item.captionLines;

  const bottomAreaTop = img.height + margin;
  const bottomAreaBottom = canvas.height;
  const bottomAreaCenterY = (bottomAreaTop + bottomAreaBottom) / 2;

  let baseY = bottomAreaCenterY + state.offsetY;

  const centerX = canvas.width / 2;

  // ★ 最初の描画でも中央揃え＆色を適用
  ctx.textAlign = "center";
  ctx.textBaseline = "alphabetic";
  ctx.fillStyle = state.fontColor;

  /* ==========================
       ★ 自由キャプション（複数行）
    =========================== */
  if (state.captionText.trim() !== "") {
    const freeLines = state.captionText.split(/\r?\n/);

    // ▼ 追加：斜体・ウェイトの取得
    const italic = state.freeCaptionItalic ? "italic " : "";
    const weight = state.freeCaptionWeight || 400;

    // ▼ 完成版フォント指定
    ctx.font = `${italic}${weight} ${state.fontSize}px "${state.fontFamily}", sans-serif`;
    ctx.fillStyle = state.fontColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "alphabetic";

    // ▼ 行数ぶん上にずらす
    baseY -= (freeLines.length * state.fontSize * state.lineGap);

    for (const line of freeLines) {
      ctx.fillText(line, centerX, baseY);
      baseY += state.fontSize * state.lineGap;
    }

    baseY += state.captionGap;
  }

  /* ==========================
       既存の line1（太字）
    =========================== */
  ctx.font = `700 ${state.fontSize}px "${state.fontFamily}", sans-serif`;
  ctx.fillText(line1, centerX, baseY - state.fontSize * state.lineGap);

  /* ==========================
       既存の line2（通常）
    =========================== */
  ctx.font = `400 ${state.fontSize}px "${state.fontFamily}", sans-serif`;
  ctx.fillText(line2, centerX, baseY);
}

/* ==========================
   書き出し（フォルダ保存対応）
========================== */
async function saveToFolder(filename, blob) {
  if (!state.outputDirHandle) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 2000);
    return;
  }

  const fileHandle = await state.outputDirHandle.getFileHandle(filename, { create: true });
  const writable = await fileHandle.createWritable();
  await writable.write(blob);
  await writable.close();
}

function downloadCanvas(filename) {
  return new Promise(resolve => {
    canvas.toBlob(async (blob) => {
      await saveToFolder(filename, blob);
      resolve();
    }, "image/jpeg", 0.95);
  });
}

/* ==========================
   UI 更新
========================== */
function refreshThumbList() {
  thumbList.innerHTML = "";
  state.items.forEach((item, i) => {
    const div = document.createElement("div");
    div.className = "thumb-item" + (i === state.currentIndex ? " active" : "");
    div.textContent = item.file.name;
    div.onclick = () => {
      state.currentIndex = i;
      updateView();
    };
    thumbList.appendChild(div);
  });
}

function updateExifInfo() {
  exifInfo.innerHTML = "";
  if (state.currentIndex < 0 || state.currentIndex >= state.items.length) return;

  const item = state.items[state.currentIndex];
  const exif = item.exif;

  let model = exif.Model || "(不明)";
  if (model === "DC-G9M2") model = "LUMIX G9Pro2";

  let lens = sanitizeLensName(exif.LensModel || "");
  if (lens.includes("LEICA DG 50-200"))
    lens = "LEICA DG VARIO-ELMARIT 50-200mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("LEICA DG 12-60"))
    lens = "LEICA DG VARIO-ELMARIT 12-60mm / F2.8-4.0 ASPH. / POWER O.I.S.";
  if (lens.includes("OLYMPUS M.300mm F4.0"))
    lens = "M.ZUIKO DIGITAL ED 300mm F4.0 IS PRO";
  if (!lens) lens = "(不明)";

  function add(label, value) {
    const div = document.createElement("div");
    div.textContent = `${label}: ${value}`;
    exifInfo.appendChild(div);
  }

  add("ファイル名", item.file.name);
  add("解像度", `${item.width} × ${item.height}`);
  add("DateTimeOriginal", exif.DateTimeOriginal || "(なし)");
  add("CAMERA", model);
  add("LENS", lens);
  add("CameraSerialNumber", exif.CameraSerialNumber || "(不明)");
  add("出力ファイル名", item.outputName);
}

function updateView() {
  refreshThumbList();
  updateExifInfo();
  drawCurrent();
}

/* ==========================
   プリセット
========================== */
presetSelect.onchange = async () => {
  const p = presetSelect.value;

  if (p === "g9m2") {
    state.marginRatio = 0.03;
    state.lineGap = 1.55;
    state.fontSize = 112;
    state.fontFamily = "Zen Antique";
    state.fontColor = "#9e9e9e";
    state.offsetY = 90;
    state.extraBottomMargin = 470;
    state.captionGap = 40;
  }

  if (p === "v1") {
    state.marginRatio = 0.03;
    state.lineGap = 1.5;
    state.fontSize = 114;
    state.fontFamily = "Zen Antique";
    state.fontColor = "#9e9e9e";
    state.offsetY = 80;
    state.extraBottomMargin = 600;
    state.captionGap = 40;
  }

  if (p === "none") return;

  // UI反映（ここはそのまま）
  marginRatioSlider.value = state.marginRatio;
  marginRatioInput.value = state.marginRatio;
  lineGapSlider.value = state.lineGap;
  lineGapInput.value = state.lineGap;
  fontSizeSlider.value = state.fontSize;
  fontSizeInput.value = state.fontSize;
  fontFamilySelect.value = state.fontFamily;
  fontColorInput.value = state.fontColor;
  offsetYSlider.value = state.offsetY;
  offsetYInput.value = state.offsetY;
  extraBottomSlider.value = state.extraBottomMargin;
  extraBottomInput.value = state.extraBottomMargin;
  captionGapSlider.value = state.captionGap;
  captionGapInput.value = state.captionGap;

  // ★ フォントロードを待つ
  await document.fonts.load(`${state.fontSize}px "${state.fontFamily}"`);

  drawCurrent();
};

/* ==========================
   UI イベント（スライダー ↔ 数値入力）
========================== */
marginRatioSlider.oninput = () => {
  state.marginRatio = Number(marginRatioSlider.value);
  marginRatioInput.value = state.marginRatio;
  syncMobileFromState();
  drawCurrent();
};

marginRatioInput.oninput = () => {
  state.marginRatio = Number(marginRatioInput.value);
  marginRatioSlider.value = state.marginRatio;
  syncMobileFromState();
  drawCurrent();
};

lineGapSlider.oninput = () => {
  state.lineGap = Number(lineGapSlider.value);
  lineGapInput.value = state.lineGap;
  drawCurrent();
};

lineGapInput.oninput = () => {
  state.lineGap = Number(lineGapInput.value);
  lineGapSlider.value = state.lineGap;
  drawCurrent();
};

fontSizeSlider.oninput = () => {
  state.fontSize = Number(fontSizeSlider.value);
  fontSizeInput.value = state.fontSize;
  syncMobileFromState();
  drawCurrent();
};

fontSizeInput.oninput = e => {
  state.fontSize = Number(e.target.value);
  fontSizeSlider.value = state.fontSize;
  syncMobileFromState();
  drawCurrent();
};

fontColorInput.oninput = e => {
  state.fontColor = e.target.value;
  drawCurrent();
};

fontFamilySelect.onchange = async e => {
  const f = e.target.value;
  state.fontFamily = f;

  await document.fonts.load(`${state.fontSize}px "${f}"`);

  syncMobileFromState();
  drawCurrent();
};

// ▼ ホイールでフォント変更
fontFamilySelect.addEventListener("wheel", async (e) => {
  e.preventDefault();

  const options = fontFamilySelect.options;
  let index = fontFamilySelect.selectedIndex;

  if (e.deltaY > 0) {
    index = Math.min(index + 1, options.length - 1);
  } else {
    index = Math.max(index - 1, 0);
  }

  fontFamilySelect.selectedIndex = index;
  state.fontFamily = options[index].value;

  await document.fonts.load(`${state.fontSize}px "${state.fontFamily}"`);

  syncMobileFromState();
  drawCurrent();
});

offsetYSlider.oninput = () => {
  state.offsetY = Number(offsetYSlider.value);
  offsetYInput.value = state.offsetY;
  syncMobileFromState();
  drawCurrent();
};

offsetYInput.oninput = e => {
  state.offsetY = Number(e.target.value);
  offsetYSlider.value = state.offsetY;
  syncMobileFromState();
  drawCurrent();
};

extraBottomSlider.oninput = () => {
  state.extraBottomMargin = Number(extraBottomSlider.value);
  extraBottomInput.value = state.extraBottomMargin;
  syncMobileFromState();
  drawCurrent();
};

extraBottomInput.oninput = () => {
  state.extraBottomMargin = Number(extraBottomInput.value);
  extraBottomSlider.value = state.extraBottomMargin;
  syncMobileFromState();
  drawCurrent();
};

orientationSelect.onchange = e => {
  state.orientation = e.target.value;
  drawCurrent();
};

/* ★ 自由キャプション（追加） */
freeCaptionInput.oninput = e => {
  state.captionText = e.target.value;
  drawCurrent();
};

/* ★ 自由キャプションと機種名の間隔（追加） */
captionGapSlider.oninput = () => {
  state.captionGap = Number(captionGapSlider.value);
  captionGapInput.value = state.captionGap;
  syncMobileFromState();
  drawCurrent();
};

captionGapInput.oninput = () => {
  state.captionGap = Number(captionGapInput.value);
  captionGapSlider.value = state.captionGap;
  syncMobileFromState();
  drawCurrent();
};

// ★ 自由キャプションの斜体
freeCaptionItalic.onchange = e => {
  state.freeCaptionItalic = e.target.checked;
  drawCurrent();
};

// ★ 自由キャプションのウェイト
freeCaptionWeight.onchange = e => {
  state.freeCaptionWeight = Number(e.target.value);
  drawCurrent();
};

/* ==========================
   書き出しフォルダ選択
========================== */
selectFolderBtn.onclick = async () => {
  try {
    const handle = await window.showDirectoryPicker();
    state.outputDirHandle = handle;
    folderStatus.textContent = "選択済み：" + handle.name;
  } catch (e) {
    folderStatus.textContent = "フォルダ選択がキャンセルされました";
  }
};

/* ==========================
   ナビゲーション
========================== */
prevBtn.onclick = () => {
  if (state.items.length === 0) return;
  state.currentIndex = (state.currentIndex - 1 + state.items.length) % state.items.length;
  updateView();
};

nextBtn.onclick = () => {
  if (state.items.length === 0) return;
  state.currentIndex = (state.currentIndex + 1) % state.items.length;
  updateView();
};

/* ==========================
   書き出し
========================== */
renderCurrentBtn.onclick = async () => {
  if (state.currentIndex < 0) return;
  drawCurrent();
  const item = state.items[state.currentIndex];
  await downloadCanvas(item.outputName);
  setStatus(`"${item.outputName}" を書き出しました`);
};

renderAllBtn.onclick = async () => {
  if (state.items.length === 0) return;
  setStatus("一括書き出し中…");

  for (let i = 0; i < state.items.length; i++) {
    state.currentIndex = i;
    drawCurrent();
    const item = state.items[i];
    await downloadCanvas(item.outputName);
  }

  updateView();
  setStatus("一括書き出し完了");
};

/* ==========================
   ドロップゾーン
========================== */
dropZone.onclick = () => fileInput.click();

dropZone.ondragover = e => {
  e.preventDefault();
  dropZone.classList.add("dragover");
};
dropZone.ondragleave = () => dropZone.classList.remove("dragover");
dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove("dragover");
  loadFiles(e.dataTransfer.files);
};

fileInput.onchange = e => {
  loadFiles(e.target.files);
  fileInput.value = "";
};

/* ==========================
   スマホ用 UI 要素
========================== */
const mobileToolbarButtons = document.querySelectorAll(".mobile-toolbar button");
const mobileFontFamilySelect = document.getElementById("mobileFontFamilySelect");
const mobileFontSizeSlider = document.getElementById("mobileFontSizeSlider");
const mobileFontSizeValue = document.getElementById("mobileFontSizeValue");
const mobileOffsetYSlider = document.getElementById("mobileOffsetYSlider");
const mobileOffsetYValue = document.getElementById("mobileOffsetYValue");
const mobileMarginRatioSlider = document.getElementById("mobileMarginRatioSlider");
const mobileMarginRatioValue = document.getElementById("mobileMarginRatioValue");
const mobileExtraBottomSlider = document.getElementById("mobileExtraBottomSlider");
const mobileExtraBottomValue = document.getElementById("mobileExtraBottomValue");
const mobileCaptionGapSlider = document.getElementById("mobileCaptionGapSlider");
const mobileCaptionGapValue = document.getElementById("mobileCaptionGapValue");

/* パネル開閉 */
mobileToolbarButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const target = btn.dataset.panel;
    document.querySelectorAll(".mobile-panel").forEach(p => p.classList.remove("open"));
    const panel = document.getElementById(`panel-${target}`);
    if (panel) panel.classList.add("open");
  });
});

/* スマホ → state 反映 */
mobileFontFamilySelect.addEventListener("change", async () => {
  state.fontFamily = mobileFontFamilySelect.value;
  fontFamilySelect.value = state.fontFamily;
  await document.fonts.load(`${state.fontSize}px "${state.fontFamily}"`);
  drawCurrent();
});

mobileFontSizeSlider.addEventListener("input", () => {
  state.fontSize = Number(mobileFontSizeSlider.value);
  mobileFontSizeValue.textContent = `${state.fontSize}px`;
  fontSizeSlider.value = state.fontSize;
  fontSizeInput.value = state.fontSize;
  drawCurrent();
});

mobileOffsetYSlider.addEventListener("input", () => {
  state.offsetY = Number(mobileOffsetYSlider.value);
  mobileOffsetYValue.textContent = state.offsetY;
  offsetYSlider.value = state.offsetY;
  offsetYInput.value = state.offsetY;
  drawCurrent();
});

mobileMarginRatioSlider.addEventListener("input", () => {
  state.marginRatio = Number(mobileMarginRatioSlider.value);
  mobileMarginRatioValue.textContent = state.marginRatio.toFixed(2);
  marginRatioSlider.value = state.marginRatio;
  marginRatioInput.value = state.marginRatio;
  drawCurrent();
});

mobileExtraBottomSlider.addEventListener("input", () => {
  state.extraBottomMargin = Number(mobileExtraBottomSlider.value);
  mobileExtraBottomValue.textContent = `${state.extraBottomMargin}px`;
  extraBottomSlider.value = state.extraBottomMargin;
  extraBottomInput.value = state.extraBottomMargin;
  drawCurrent();
});

mobileCaptionGapSlider.addEventListener("input", () => {
  state.captionGap = Number(mobileCaptionGapSlider.value);
  mobileCaptionGapValue.textContent = `${state.captionGap}px`;
  captionGapSlider.value = state.captionGap;
  captionGapInput.value = state.captionGap;
  drawCurrent();
});

/* state → スマホUI 反映 */
function syncMobileFromState() {
  mobileFontFamilySelect.value = state.fontFamily;
  mobileFontSizeSlider.value = state.fontSize;
  mobileFontSizeValue.textContent = `${state.fontSize}px`;
  mobileOffsetYSlider.value = state.offsetY;
  mobileOffsetYValue.textContent = state.offsetY;
  mobileMarginRatioSlider.value = state.marginRatio;
  mobileMarginRatioValue.textContent = state.marginRatio.toFixed(2);
  mobileExtraBottomSlider.value = state.extraBottomMargin;
  mobileExtraBottomValue.textContent = `${state.extraBottomMargin}px`;
  mobileCaptionGapSlider.value = state.captionGap;
  mobileCaptionGapValue.textContent = `${state.captionGap}px`;
}

/* 初期状態 */
syncMobileFromState();
setStatus("画像を読み込んでください");
/* ==========================
   画像未読み込み時のタップ → 読み込みダイアログ
========================== */
document.querySelector(".preview-wrapper").addEventListener("click", () => {
  if (state.items.length === 0) {
    fileInput.click();
  }
});


</script>
</body>
</html>
